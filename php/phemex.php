<?php

namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use \ccxt\ExchangeError;
use \ccxt\OrderNotFound;
use \ccxt\DDoSProtection;

class phemex extends Exchange {

    public function convert_time_ns($ns) {
        return (int) floor($ns * pow(10, -6));
    }

    public function convert_e_number($eNum, $scale, $precision, $roundType) {
        return $this->decimal_to_precision($eNum * pow(10, -$scale), $roundType, $precision, DECIMAL_PLACES, PAD_WITH_ZERO);
    }

    public function convert_ev($ev, $scale, $precision) {
        return $this->convert_e_number($ev, $scale, $precision, ROUND);
    }

    public function convert_er($er, $scale, $precision) {
        return $this->convert_e_number($er, $scale, $precision, ROUND);
    }

    public function convert_ep($ep, $scale, $precision) {
        if ($ep === null) {
            return null;
        }
        return $this->convert_e_number($ep, $scale, $precision, ROUND);
    }

    public function convert_to_ep($price) {
        return $price * pow(10, 4);
    }

    public function calc_average_ep($filledEv, $valueScale, $priceScale, $filled, $contractSide) {
        if ($filled === 0) {
            return null;
        }
        if ($filledEv === 0) {
            return null;
        }
        $priceFactor = pow(10, $priceScale);
        $valueFactor = pow(10, $valueScale);
        return pow($filledEv / ($valueFactor * $filled), $contractSide) * $priceFactor;
    }

    public function calc_cost_ev($filled, $averageEp, $priceEp, $priceScale, $valueScale, $contractSide) {
        if ($filled === 0) {
            return 0;
        }
        $ep = null;
        if ($averageEp !== null) {
            $ep = $averageEp;
        } else if ($priceEp !== null) {
            $ep = $priceEp;
        }
        if ($ep === null) {
            return null;
        }
        $priceFactor = pow(10, $priceScale);
        $valueFactor = pow(10, $valueScale);
        return $filled * pow($ep / $priceFactor, $contractSide) * $valueFactor;
    }

    public function parse_response($response) {
        return $this->safe_value($response, 'data', null);
    }

    public function parse_md_response($response) {
        return $this->safe_value($response, 'result', null);
    }

    public function parse_market($product, $precisions) {
        $id = $this->safe_string($product, 'symbol');
        $quoteCurrency = $this->safe_string($product, 'quoteCurrency');
        $settlementCurrency = $this->safe_string($product, 'settlementCurrency');
        $underlyingSymbol = $this->safe_string($product, 'underlyingSymbol');
        $baseId = explode('.', $underlyingSymbol)[1];
        $quoteId = $quoteCurrency;
        $base = $this->safe_currency_code($baseId);
        $quote = $this->safe_currency_code($quoteId);
        return array(
            'id' => $id,
            'symbol' => $base . '/' . $quote,
            'base' => $base,
            'quote' => $quote,
            'baseId' => $baseId,
            'quoteId' => $quoteId,
            'contractSide' => ($quoteCurrency === $settlementCurrency) ? 1 : -1,
            'type' => 'future',
            'spot' => false,
            'future' => true,
            'active' => true,
            'priceScale' => $this->safe_integer($product, 'priceScale', 1),
            'ratioScale' => $this->safe_integer($product, 'ratioScale', 1),
            'valueScale' => $this->safe_integer($product, 'valueScale', 1),
            'precision' => $this->safe_value($precisions, $id),
            'limits' => array(
                'amount' => array(
                    'min' => 1,
                    'max' => $product['maxOrderQty'],
                ),
                'price' => array(
                    'min' => null,
                    'max' => $product['maxPriceEp'],
                ),
                'cost' => array(
                    'min' => null,
                    'max' => null,
                ),
            ),
            'info' => $product,
        );
    }

    public function parse_bid_ask($bidask, $priceKey = 0, $amountKey = 1, $priceScale = 4, $pricePrecision = 1) {
        $priceEp = $bidask[$priceKey];
        $price = floatval ($this->convert_ep($priceEp, $priceScale, $pricePrecision));
        $amount = floatval ($bidask[$amountKey]);
        return [$price, $amount];
    }

    public function parse_bids_asks($bidasks, $priceKey = 0, $amountKey = 1, $priceScale = 4, $pricePrecision = 1) {
        $result = array();
        for ($i = 0; $i < count($bidasks); $i++) {
            $bidask = $this->parse_bid_ask($bidasks[$i], $priceKey, $amountKey, $priceScale, $pricePrecision);
            $result[] = $bidask;
        }
        return $result;
    }

    public function parse_order_book($orderbook, $timestamp = null, $bidsKey = 'bids', $asksKey = 'asks', $priceKey = 0, $amountKey = 1, $market = null) {
        // $market data
        $precisions = $this->safe_value($market, 'precision');
        $priceScale = $this->safe_integer($market, 'priceScale');
        $pricePrecision = $this->safe_integer($precisions, 'price');
        $rawBids = $this->safe_value($orderbook, $bidsKey);
        $rawAsks = $this->safe_value($orderbook, $asksKey);
        return array(
            'bids' => $this->sort_by($this->parse_bids_asks($rawBids, $priceKey, $amountKey, $priceScale, $pricePrecision), 0, true),
            'asks' => $this->sort_by($this->parse_bids_asks($rawAsks, $priceKey, $amountKey, $priceScale, $pricePrecision), 0),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'nonce' => null,
        );
    }

    public function parse_order_status($status) {
        $statuses = array(
            'Untriggered' => 'open',
            'Deactivated' => 'closed',
            'Triggered' => 'open',
            'Rejected' => 'rejected',
            'New' => 'open',
            'PartiallyFilled' => 'open',
            'Filled' => 'closed',
            'Canceled' => 'canceled',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function parse_order($order, $market = null) {
        $marketID = $market['id'];
        // $market data
        $contractSide = $this->safe_integer($market, $marketID, 1);
        $precisions = $this->safe_value($market, 'precision');
        $priceScale = $this->safe_integer($market, 'priceScale');
        $pricePrecision = $this->safe_integer($precisions, 'price');
        $valueScale = $this->safe_integer($market, 'valueScale');
        $valuePrecision = $this->safe_integer($precisions, 'value');
        // $order data
        $id = $this->safe_string($order, 'orderID');
        $type = $this->safe_string_lower($order, 'ordType');
        $side = $this->safe_string_lower($order, 'side');
        $ordStatus = $this->safe_string($order, 'ordStatus');
        $actionTimeNs = $this->safe_integer($order, 'actionTimeNs', 0);
        $transactTimeNs = $this->safe_integer($order, 'transactTimeNs', 0);
        $priceEp = $this->safe_integer($order, 'priceEp', 0);
        $amount = $this->safe_integer($order, 'orderQty', 0);
        $filled = $this->safe_integer($order, 'cumQty', 0);
        $filledEv = $this->safe_integer($order, 'cumValueEv', 0);
        // derived data
        $timestamp = $this->convert_time_ns($actionTimeNs);
        $remaining = 0;
        if ($amount !== 0) {
            if ($filled !== 0) {
                $remaining = max ($amount - $filled, 0);
            }
        }
        $averageEp = $this->calc_average_ep($filledEv, $valueScale, $priceScale, $filled, $contractSide);
        $average = $this->convert_ep($averageEp, $priceScale, $pricePrecision);
        $costEv = $this->calc_cost_ev($filled, $averageEp, $priceEp, $priceScale, $valueScale, $contractSide);
        return array(
            'info' => $order,
            'id' => $id,
            'datetime' => $this->iso8601($timestamp),
            'timestamp' => $timestamp,
            'lastTradeTimestamp' => $this->convert_time_ns($transactTimeNs),
            'symbol' => $market['symbol'],
            'type' => $type,
            'side' => $side,
            'price' => $this->convert_ep($priceEp, $priceScale, $pricePrecision),
            'amount' => $amount,
            'cost' => $this->convert_ev($costEv, $valueScale, $valuePrecision),
            'average' => $average,
            'filled' => $filled,
            'remaining' => $remaining,
            'status' => $this->parse_order_status($ordStatus),
            'fee' => null,
        );
    }

    public function parse_orders($orders, $market = null, $since = null, $limit = null, $params = array ()) {
        $result = array();
        $ordersCount = is_array($orders) ? count($orders) : 0;
        for ($i = 0; $i < $ordersCount; $i++) {
            $result[] = $this->parse_order($orders[$i], $market);
        }
        return $result;
    }

    public function parse_my_trade($trade, $market = null) {
        $marketID = $market['id'];
        // $market data
        $contractSide = $this->safe_integer($market, $marketID, 1);
        $precisions = $this->safe_value($market, 'precision');
        $priceScale = $this->safe_integer($market, 'priceScale');
        $pricePrecision = $this->safe_integer($precisions, 'price');
        $valueScale = $this->safe_integer($market, 'valueScale');
        $valuePrecision = $this->safe_integer($precisions, 'value');
        // $trade data
        $transactTimeNs = $this->safe_integer($trade, 'transactTimeNs', 0);
        $timestamp = $this->convert_time_ns($transactTimeNs);
        $type = $this->safe_string_lower($trade, 'ordType');
        $side = $this->safe_string_lower($trade, 'side');
        $execStatus = $this->safe_string($trade, 'execStatus');
        $execPriceEp = $this->safe_integer($trade, 'execPriceEp', 0);
        $priceEp = $this->safe_integer($trade, 'priceEp', 0);
        $amount = $this->safe_integer($trade, 'execQty', 0);
        $costEv = $this->calc_cost_ev($amount, $execPriceEp, $priceEp, $priceScale, $valueScale, $contractSide);
        $execFeeEv = $this->safe_integer($trade, 'execFeeEv', 0);
        $feeRateEr = $this->safe_integer($trade, 'feeRateEr', 0);
        $takerOrMaker = null;
        if ($execStatus === 'TakerFill') {
            $takerOrMaker = 'taker';
        } else if ($execStatus === 'MakerFill') {
            $takerOrMaker = 'maker';
        }
        return array(
            'info' => $trade,
            'id' => $this->safe_string($trade, 'execID'),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $market['symbol'],
            'order' => $this->safe_string($trade, 'orderID'),
            'type' => $type,
            'side' => $side,
            'takerOrMaker' => $takerOrMaker,
            'price' => $this->convert_ep($execPriceEp, $priceScale, $pricePrecision),
            'amount' => $amount,
            'cost' => $this->convert_ev($costEv . $execFeeEv, $valueScale, $valuePrecision),
            'fee' => array(
                'cost' => $this->convert_ev($execFeeEv, $valueScale, $valuePrecision),
                'currency' => $this->safe_string($trade, 'currency'),
                'rate' => $this->convert_er($feeRateEr, 8, 8),
            ),
        );
    }

    public function parse_my_trades($trades, $market = null) {
        $result = array();
        $tradesCount = is_array($trades) ? count($trades) : 0;
        for ($i = 0; $i < $tradesCount; $i++) {
            $result[] = $this->parse_my_trade($trades[$i], $market);
        }
        return $result;
    }

    public function parse_md_trade($trade, $market = null) {
        // $market data
        $precisions = $this->safe_value($market, 'precision');
        $priceScale = $this->safe_integer($market, 'priceScale');
        $pricePrecision = $this->safe_integer($precisions, 'price');
        $timestampNs = $trade[0];
        $timestamp = $this->convert_time_ns($timestampNs);
        $side = strtolower($trade[1]);
        $priceEp = $trade[2];
        $amount = $trade[3];
        return array(
            'info' => $trade,
            'id' => null,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $market['symbol'],
            'order' => null,
            'type' => null,
            'side' => $side,
            'takerOrMaker' => null,
            'price' => floatval ($this->convert_ep($priceEp, $priceScale, $pricePrecision)),
            'amount' => $amount,
            'cost' => null,
            'fee' => array(
                'cost' => null,
                'currency' => null,
                'rate' => null,
            ),
        );
    }

    public function parse_md_trades($trades, $market = null) {
        $result = array();
        $tradesCount = is_array($trades) ? count($trades) : 0;
        for ($i = 0; $i < $tradesCount; $i++) {
            $result[] = $this->parse_md_trade($trades[$i], $market);
        }
        return $result;
    }

    public function describe() {
        return $this->deep_extend(parent::describe (), array(
            'id' => 'phemex',
            'name' => 'Phemex',
            'countries' => ['SC'],
            'version' => 'v1',
            'userAgent' => null,
            'rateLimit' => 2000,
            'has' => array(
                'cancelAllOrders' => false,
                'cancelOrder' => true,
                'cancelOrders' => false,
                'CORS' => false,
                'createDepositAddress' => false,
                'createLimitBuyOrder' => true,
                'createLimitSellOrder' => true,
                'createMarketBuyOrder' => true,
                'createMarketSellOrder' => true,
                'createOrder' => true,
                'deposit' => false,
                'editOrder' => false,
                'fetchBalance' => true,
                'fetchBidsAsks' => false,
                'fetchClosedOrders' => true,
                'fetchCurrencies' => false,
                'fetchDepositAddress' => false,
                'fetchDeposits' => false,
                'fetchFundingFees' => false,
                'fetchL2OrderBook' => false,
                'fetchLedger' => false,
                'fetchMarkets' => true,
                'fetchMyTrades' => true,
                'fetchOHLCV' => false,
                'fetchOpenOrders' => true,
                'fetchOrder' => true,
                'fetchOrderBook' => true,
                'fetchOrderBooks' => false,
                'fetchOrders' => true,
                'fetchStatus' => false,
                'fetchTicker' => false,
                'fetchTickers' => false,
                'fetchTime' => false,
                'fetchTrades' => true,
                'fetchTradingFee' => false,
                'fetchTradingFees' => false,
                'fetchTradingLimits' => false,
                'fetchTransactions' => false,
                'fetchWithdrawals' => false,
                'privateAPI' => false,
                'publicAPI' => false,
                'withdraw' => false,
            ),
            'timeframes' => array(
                '1m' => '1m',
                '5m' => '5m',
                '1h' => '1h',
                '1d' => '1d',
            ),
            'urls' => array(
                'logo' => 'https://user-images.githubusercontent.com/7397642/72579020-cd03e300-3912-11ea-9371-04cbd58c31f8.png',
                'www' => 'https://phemex.com',
                'test' => array(
                    'public' => 'https://testnet.phemex.com/api',
                    'public2' => 'https://testnet-api.phemex.com',
                    'private' => 'https://testnet-api.phemex.com',
                ),
                'api' => array(
                    'public' => 'https://phemex.com/api',
                    'public2' => 'https://api.phemex.com',
                    'private' => 'https://api.phemex.com',
                ),
                'doc' => array(
                    'https://github.com/phemex/phemex-api-docs',
                ),
                'api_management' => 'https://phemex.com/web/account/api/list',
                'referral' => 'https://phemex.com/?referralCode=D6XAJ',
                'fees' => 'https://phemex.com/fees-conditions',
            ),
            'api' => array(
                'public' => array(
                    'get' => array(
                        'exchange/public/products',
                    ),
                ),
                'public2' => array(
                    'get' => array(
                        'md/orderbook',
                        'md/trade',
                    ),
                ),
                'private' => array(
                    'get' => array(
                        'accounts/accountPositions',
                        'phemex-user/order',
                        'phemex-user/order/list',
                        'phemex-user/order/orderList',
                        'phemex-user/order/trade',
                        'orders/activeList',
                    ),
                    'post' => array(
                        'orders',
                    ),
                    'put' => array(),
                    'delete' => array(
                        'orders/cancel',
                    ),
                ),
            ),
            'exceptions' => array(
                'exact' => array(
                    'Invalid API Key.' => '\\ccxt\\AuthenticationError',
                    'This key is disabled.' => '\\ccxt\\PermissionDenied',
                    'Access Denied' => '\\ccxt\\PermissionDenied',
                    'Duplicate clOrdID' => '\\ccxt\\InvalidOrder',
                    'orderQty is invalid' => '\\ccxt\\InvalidOrder',
                    'Invalid price' => '\\ccxt\\InvalidOrder',
                    'Invalid stopPx for ordType' => '\\ccxt\\InvalidOrder',
                ),
                'broad' => array(
                    'Signature not valid' => '\\ccxt\\AuthenticationError',
                    'overloaded' => '\\ccxt\\ExchangeNotAvailable',
                    'Account has insufficient Available Balance' => '\\ccxt\\InsufficientFunds',
                    'Service unavailable' => '\\ccxt\\ExchangeNotAvailable', // array("error":array("message":"Service unavailable","name":"HTTPError"))
                ),
            ),
            'precisionMode' => DECIMAL_PLACES,
        ));
    }

    public function fetch_markets($params = array ()) {
        $precisions = array(
            'BTCUSD' => array(
                'amount' => 0,
                'price' => 1,
                'value' => 8,
            ),
            'ETHUSD' => array(
                'amount' => 0,
                'price' => 2,
                'value' => 2,
            ),
            'XRPUSD' => array(
                'amount' => 0,
                'price' => 4,
                'value' => 2,
            ),
        );
        $method = 'publicGetExchangePublicProducts';
        $response = $this->$method ($params);
        $products = $this->safe_value($response, 'data');
        $productsCount = is_array($products) ? count($products) : 0;
        $result = array();
        for ($i = 0; $i < $productsCount; $i++) {
            $market = $this->parse_market($products[$i], $precisions);
            $result[] = $market;
        }
        return $result;
    }

    public function fetch_order_book($symbol, $limit = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $marketID = $market['id'];
        $method = 'public2GetMdOrderbook';
        $response = $this->$method (array( 'symbol' => $marketID ));
        $data = $this->parse_md_response($response);
        $book = $this->safe_value($data, 'book');
        return $this->parse_order_book($book, null, 'bids', 'asks', 0, 1, $market);
    }

    public function fetch_trades($symbol, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $marketID = $market['id'];
        $method = 'public2GetMdTrade';
        $response = $this->$method (array( 'symbol' => $marketID ));
        $data = $this->parse_md_response($response);
        $trades = $this->safe_value($data, 'trades');
        return $this->parse_md_trades($this->sort_by($trades, 0), $market);
    }

    public function fetch_balance($params = array ()) {
        $this->load_markets();
        $method = 'privateGetAccountsAccountPositions';
        $btcResponse = $this->$method (array( 'currency' => 'BTC' ));
        $usdResponse = $this->$method (array( 'currency' => 'USD' ));
        $btcAccount = $this->safe_value($this->parse_response($btcResponse), 'account');
        $btcBalanceEv = $this->safe_value($btcAccount, 'accountBalanceEv');
        $btcTotalUsedBalanceEv = $this->safe_value($btcAccount, 'totalUsedBalanceEv');
        $usdAccount = $this->safe_value($this->parse_response($usdResponse), 'account');
        $usdBalanceEv = $this->safe_value($usdAccount, 'accountBalanceEv');
        $usdTotalUsedBalanceEv = $this->safe_value($usdAccount, 'totalUsedBalanceEv');
        $BTC = array(
            'free' => $this->convert_ev($btcBalanceEv - $btcTotalUsedBalanceEv, 8, 8),
            'used' => $this->convert_ev($btcTotalUsedBalanceEv, 8, 8),
            'total' => $this->convert_ev($btcBalanceEv, 8, 8),
        );
        $USD = array(
            'free' => $this->convert_ev($usdBalanceEv - $usdTotalUsedBalanceEv, 4, 2),
            'used' => $this->convert_ev($usdTotalUsedBalanceEv, 4, 2),
            'total' => $this->convert_ev($usdBalanceEv, 4, 2),
        );
        return array(
            'free' => array(
                'BTC' => $this->safe_string($BTC, 'free'),
                'USD' => $this->safe_string($USD, 'free'),
            ),
            'used' => array(
                'BTC' => $this->safe_string($BTC, 'used'),
                'USD' => $this->safe_string($USD, 'used'),
            ),
            'total' => array(
                'BTC' => $this->safe_string($BTC, 'total'),
                'USD' => $this->safe_string($USD, 'total'),
            ),
            'BTC' => $BTC,
            'USD' => $USD,
            'info' => array(),
        );
    }

    public function fetch_order($id, $symbol = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $marketID = $market['id'];
        $method = 'privateGetPhemexUserOrder';
        $response = $this->$method (array( 'orderID' => $id, 'symbol' => $marketID ));
        $orders = $this->parse_response($response);
        $orderCount = is_array($orders) ? count($orders) : 0;
        if ($orderCount > 0) {
            return $this->parse_order($orders[0], $market);
        }
        throw new OrderNotFound($this->id . ' => The order ' . $id . ' not found.');
    }

    public function fetch_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $marketID = $market['id'];
        $method = 'privateGetPhemexUserOrderList';
        $response = $this->$method (array( 'symbol' => $marketID, 'start' => $since, 'limit' => $limit ));
        $data = $this->parse_response($response);
        $orders = $this->safe_value($data, 'rows', array());
        return $this->parse_orders($orders, $market);
    }

    public function fetch_open_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $marketID = $market['id'];
        $method = 'privateGetOrdersActiveList';
        try {
            $response = $this->$method (array( 'symbol' => $marketID ));
            $data = $this->parse_response($response);
            $orders = $this->safe_value($data, 'rows');
            return $this->parse_orders($orders, $market);
        } catch (Exception $e) {
            return array();
        }
    }

    public function fetch_closed_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $marketID = $market['id'];
        $method = 'privateGetPhemexUserOrderList';
        $response = $this->$method (array( 'symbol' => $marketID, 'start' => $since, 'limit' => $limit ));
        $data = $this->parse_response($response);
        $rawOrders = $this->safe_value($data, 'rows');
        $orders = $this->parse_orders($rawOrders, $market);
        $orderCount = is_array($orders) ? count($orders) : 0;
        $result = array();
        for ($i = 0; $i < $orderCount; $i++) {
            $order = $orders[$i];
            $status = $this->safe_string($order, 'status');
            if ($status === 'closed') {
                $result[] = $order;
            }
        }
        return $result;
    }

    public function create_order($symbol, $type, $side, $amount, $price = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $marketID = $market['id'];
        $request = array(
            'clOrdID' => $this->uuid(),
            'symbol' => $marketID,
            'side' => $this->capitalize($side),
            'orderQty' => $amount,
            'ordType' => $this->capitalize($type),
            'postOnly' => false,
            'reduceOnly' => false,
            'timeInForce' => $this->safe_string($params, 'timeInForce', 'GoodTillCancel'),
        );
        if ($price !== null) {
            $request['priceEp'] = $this->convert_to_ep($price);
        }
        $method = 'privatePostOrders';
        $response = $this->$method (array_merge($request, $params));
        $order = $this->parse_order($response, $market);
        $id = $this->safe_string($order, 'id');
        $this->orders[$id] = $order;
        return array_merge(array( 'info' => $response ), $order);
    }

    public function cancel_order($id, $symbol = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $marketID = $market['id'];
        $method = 'privateDeleteOrdersCancel';
        try {
            $response = $this->$method (array( 'orderID' => $id, 'symbol' => $marketID ));
            $order = $this->parse_response($response);
            return $this->parse_order($order, $market);
        } catch (Exception $e) {
            throw new OrderNotFound($this->id . ' => The $order ' . $id . ' not found.');
        }
    }

    public function fetch_my_trades($symbol = null, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $marketID = $market['id'];
        $method = 'privateGetPhemexUserOrderTrade';
        $response = $this->$method (array( 'symbol' => $marketID, 'start' => $since, 'limit' => $limit ));
        $data = $this->parse_response($response);
        $trades = $this->safe_value($data, 'rows', array());
        return $this->parse_my_trades($trades, $market);
    }

    public function handle_errors($statusCode, $statusText, $url, $method, $responseHeaders, $responseBody, $response, $requestHeaders, $requestBody) {
        if ($statusCode === 429) {
            throw new DDoSProtection($this->id . ' ' . (string) $statusCode . ' ' . $statusText . ' ' . $requestBody);
        }
        $code = $this->safe_value($response, 'code', 0);
        if ($code !== 0) {
            $message = $this->safe_string($response, 'msg');
            throw new ExchangeError($this->id . ' ' . $message);
        }
    }

    public function nonce() {
        return $this->milliseconds();
    }

    public function sign($path, $api = 'public', $method = 'GET', $params = array (), $headers = null, $body = null) {
        $urlPath = '/' . $path;
        $querystring = '';
        if ($method === 'GET' || $method === 'DELETE') {
            $keys = is_array($params) ? array_keys($params) : array();
            $keysCount = is_array($keys) ? count($keys) : 0;
            if ($keysCount > 0) {
                $cleanParams = array();
                for ($i = 0; $i < $keysCount; $i++) {
                    $key = $keys[$i];
                    if ($params[$key] !== null) {
                        $cleanParams[$key] = $params[$key];
                    }
                }
                $cleanKeys = is_array($cleanParams) ? array_keys($cleanParams) : array();
                $cleanKeysCount = is_array($cleanKeys) ? count($cleanKeys) : 0;
                if ($cleanKeysCount > 0) {
                    $querystring = $this->urlencode_with_array_repeat($cleanParams);
                }
            }
        } else {
            $body = $this->json($params);
        }
        $url = $this->urls['api'][$api] . $urlPath . '';
        if ($querystring !== '') {
            $url .= '?' . $querystring;
        }
        if ($this->apiKey && $this->secret) {
            $expiry = $this->number_to_string($this->seconds() . 2 * 60);
            $content = $urlPath . $querystring . $expiry;
            if ($body) {
                $content .= $body;
            }
            $signature = $this->hmac($content, $this->secret);
            $headers = array(
                'Content-Type' => 'application/json',
                'x-phemex-access-token' => $this->apiKey,
                'x-phemex-request-expiry' => $expiry,
                'x-phemex-request-signature' => $signature,
            );
        }
        return array( 'url' => $url, 'method' => $method, 'headers' => $headers, 'body' => $body );
    }
}
