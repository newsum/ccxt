<?php

namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import

class bybit extends Exchange {

    public function describe () {
        return array_replace_recursive(parent::describe (), array(
            'id' => 'bybit',
            'name' => 'Bybit',
            'countries' => array( 'SG' ), // Singapore
            'userAgent' => 'sdk_ccxt/bybit_1.0',
            'rateLimit' => 100,
            'has' => array(
                'fetchDepositAddress' => false,
                'CORS' => false,
                'fetchTickers' => true,
                'fetchTicker' => true,
                'fetchOHLCV' => true,
                'fetchMyTrades' => true,
                'fetchTrades' => false,
                'fetchOrder' => true,
                'fetchOrders' => true,
                'fetchOpenOrders' => true,
                'fetchClosedOrders' => true,
                'withdraw' => false,
                'fetchDeposits' => true,
                'fetchWithdrawals' => true,
                'fetchTransactions' => false,
            ),
            'timeframes' => array(
                '1m' => '1',
                '3m' => '3',
                '5m' => '5',
                '15m' => '15',
                '30m' => '30',
                '1h' => '60',
                '2h' => '120',
                '4h' => '240',
                '6h' => '360',
                '9h' => '720',
                '1d' => 'D',
                '1M' => 'M',
                '1w' => 'W',
                '1Y' => 'Y',
            ),
            'debug' => false, // set true to use testnet
            'urls' => array(
                'test' => array(
                    'v2' => 'http://api-testnet.bybit.com/v2',
                    'wapi' => 'https://api-testnet.bybit.com',
                    'public' => 'https://api-testnet.bybit.com/open-api',
                    'private' => 'https://api-testnet.bybit.com/open-api',
                ),
                'api' => array(
                    'v2' => 'https://api.bybit.com/v2',
                    'wapi' => 'https://api.bybit.com',
                    'public' => 'https://api.bybit.com/open-api',
                    'private' => 'https://api.bybit.com/open-api',
                ),
                'logo' => 'https://user-images.githubusercontent.com/3198806/66993457-30a52700-f0fe-11e9-810c-a4a51e36fd20.png',
                'www' => 'https://www.bybit.com',
                'doc' => array(
                    'https://github.com/bybit-exchange/bybit-official-api-docs',
                ),
                'fees' => 'https://help.bybit.com/hc/en-us/articles/360007291173-Trading-Fee',
            ),
            'api' => array(
                'v2' => array(
                    'get' => array(
                        'public/time',
                        'public/symbols',
                        'public/tickers',
                        'public/ticker',
                        'public/kline/list',
                        'public/orderBook/L2',
                        'private/execution/list',
                    ),
                ),
                'wapi' => array(
                    'get' => array(
                        'position/list',
                    ),
                ),
                'private' => array(
                    'get' => array(
                        'order/list',
                        'stop-order/list',
                        'wallet/fund/records',
                        'wallet/withdraw/list',
                    ),
                    'post' => array(
                        'order/create',
                        'order/cancel',
                        'stop-order/create',
                        'stop-order/cancel',
                    ),
                ),
            ),
            'fees' => array(
                'trading' => array(
                    'tierBased' => false,
                    'percentage' => true,
                    'taker' => 0.00075,
                    'maker' => -0.00025,
                ),
            ),
            // exchange-specific options
            'options' => array(
                'recvWindow' => 5 * 1000, // 5 seconds by default
                'timeDifference' => 0,
                'adjustTime' => false, // set true to sync server time before api call
            ),
            'exceptions' => array(
                '-1' => '\\ccxt\\ExchangeNotAvailable',
                '20010' => '\\ccxt\\InvalidOrder', // createOrder -> 'invalid qty' or others
                '10002' => '\\ccxt\\InvalidNonce', // 'your time is ahead of server'
                '10003' => '\\ccxt\\AuthenticationError', // api_key invalid,
                '10004' => '\\ccxt\\AuthenticationError', // invalid sign,
                '10005' => '\\ccxt\\AuthenticationError', // permission denied
                '10010' => '\\ccxt\\AuthenticationError', // ip mismatch
            ),
        ));
    }

    public function nonce () {
        return $this->milliseconds () - $this->options['timeDifference'];
    }

    public function load_server_time_difference () {
        $response = $this->v2GetPublicTime ();
        $after = $this->milliseconds ();
        $serverTime = intval ($response['time_now']) * 1000;
        $this->options['timeDifference'] = intval ($after - $serverTime);
        return $this->options['timeDifference'];
    }

    public function fetch_markets ($params = array ()) {
        if ($this->options['adjustTime']) {
            $this->load_server_time_difference ();
        }
        $response = $this->v2GetPublicSymbols ($params);
        $data = $this->safe_value($response, 'result', array());
        $result = array();
        for ($i = 0; $i < count($data); $i++) {
            $market = $data[$i];
            $id = $this->safe_string($market, 'name');
            $baseId = $this->safe_string($market, 'base_currency');
            $quoteId = $this->safe_string($market, 'quote_currency');
            $active = $this->safe_value($market, 'active', true);
            $base = $this->safe_currency_code($baseId);
            $quote = $this->safe_currency_code($quoteId);
            $symbol = $base . '/' . $quote;
            $result[] = array(
                'id' => $id,
                'symbol' => $symbol,
                'base' => $base,
                'quote' => $quote,
                'baseId' => $baseId,
                'quoteId' => $quoteId,
                'active' => $active,
                'info' => $market,
            );
        }
        return $result;
    }

    public function fetch_ticker ($symbol, $params = array ()) {
        $this->load_markets();
        $market = $this->market ($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        $response = $this->v2GetPublicTickers (array_merge($request, $params));
        return $this->parse_ticker($response['result'][0]);
    }

    public function fetch_tickers ($symbol = null, $params = array ()) {
        $this->load_markets();
        $response = $this->v2GetPublicTickers ();
        return $this->parse_tickers ($response['result']);
    }

    public function fetch_my_trades ($symbol = null, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        if (!(is_array($params) && array_key_exists('order_id', $params)) && ($symbol === null)) {
            throw new ArgumentsRequired($this->id . ' fetchMyTrades requires `$symbol` or `order_id` param');
        }
        $request = array();
        $market = null;
        if ($symbol !== null) {
            $market = $this->market ($symbol);
            $request['symbol'] = $market['id'];
        }
        if ($since !== null) {
            $request['startTime'] = $this->safe_integer($since / 1000);
        }
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $response = $this->v2GetPrivateExecutionList (array_merge($request, $params));
        return $this->parse_trades($this->safe_value($response['result'], 'trade_list', array()), $market, $since, $limit);
    }

    public function fetch_order_book ($symbol, $limit = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market ($symbol);
        $request = array(
            'symbol' => $market['id'],
        );
        $response = $this->v2GetPublicOrderBookL2 (array_merge($request, $params));
        $result = array(
            'bids' => array(),
            'asks' => array(),
            'timestamp' => null,
            'datetime' => null,
            'nonce' => null,
        );
        $data = $this->safe_value($response, 'result', array());
        for ($i = 0; $i < count($data); $i++) {
            $order = $data[$i];
            $side = ($order['side'] === 'Sell') ? 'asks' : 'bids';
            $amount = $this->safe_float($order, 'size');
            $price = $this->safe_float($order, 'price');
            if ($price !== null) {
                $result[$side][] = array( $price, $amount );
            }
        }
        $result['bids'] = $this->sort_by($result['bids'], 0, true);
        $result['asks'] = $this->sort_by($result['asks'], 0);
        return $result;
    }

    public function fetch_balance ($params = array ()) {
        $this->load_markets();
        $request = array();
        $response = $this->wapiGetPositionList (array_merge($request, $params));
        $retData = $response['result'];
        $result = array( 'info' => $retData );
        for ($i = 0; $i < count($retData); $i++) {
            $position = $retData[$i];
            $symbol = $this->safe_string($position, 'symbol');
            $currencyId = $this->convert_symbol_to_currency ($symbol);
            $code = $this->safe_currency_code($currencyId);
            $account = $this->account ();
            $account['total'] = $position['wallet_balance'];
            $account['used'] = $position['position_margin'] . $position['occ_closing_fee'] . $position['occ_funding_fee'] . $position['order_margin'];
            $result[$code] = $account;
        }
        return $this->parse_balance($result);
    }

    public function fetch_ohlcv ($symbol, $timeframe = '1m', $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market ($symbol);
        $request = array(
            'symbol' => $market['id'],
            'interval' => $this->timeframes[$timeframe],
        );
        if ($since === null) {
            $request['from'] = $this->seconds () - 86400; // default from 24 hours ago
        } else {
            $request['from'] = $this->truncate ($since / 1000, 0);
        }
        if ($limit !== null) {
            $request['limit'] = $limit; // default == max == 200
        }
        $response = $this->v2GetPublicKlineList (array_merge($request, $params));
        return $this->parse_ohlcvs($response['result'], $market, $timeframe, $since, $limit);
    }

    public function fetch_order ($id, $symbol = null, $params = array ()) {
        $filter = array(
            'order_id' => $id,
        );
        $response = $this->fetch_orders($symbol, null, null, array_replace_recursive($filter, $params));
        $numResults = is_array($response) ? count($response) : 0;
        if ($numResults === 1) {
            return $response[0];
        }
        throw new OrderNotFound($this->id . ' => The order ' . $id . ' not found.');
    }

    public function fetch_open_orders ($symbol = null, $since = null, $limit = null, $params = array ()) {
        $openStatusesPairs = $this->order_statuses ('open');
        $openStatusKeys = is_array($openStatusesPairs) ? array_keys($openStatusesPairs) : array();
        $request = array(
            'order_status' => implode(',', $openStatusKeys),
        );
        if ($params !== null) {
            $request = array_replace_recursive($params, $request);
        }
        return $this->fetch_orders($symbol, $since, $limit, $request);
    }

    public function fetch_closed_orders ($symbol = null, $since = null, $limit = null, $params = array ()) {
        $orders = $this->fetch_orders($symbol, $since, $limit, $params);
        return $this->filter_by($orders, 'status', 'closed');
    }

    public function fetch_orders ($symbol = null, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $market = null;
        $request = array();
        if ($symbol !== null) {
            $market = $this->market ($symbol);
            $request['symbol'] = $market['id'];
        }
        $request = array_replace_recursive($request, $params);
        $response = $this->privateGetOrderList ($request);
        return $this->parse_orders($this->safe_value($response['result'], 'data', array()), $market, $since, $limit);
    }

    public function create_order ($symbol, $type, $side, $amount, $price = null, $params = array ()) {
        $this->load_markets();
        $request = array(
            'symbol' => $this->market_id($symbol),
            'side' => $this->capitalize ($side),
            'qty' => $amount,
            'order_type' => $this->capitalize ($type),
        );
        if ($price !== null) {
            $request['price'] = $price;
        }
        $response = null;
        if ((is_array($params) && array_key_exists('stop_px', $params)) && (is_array($params) && array_key_exists('base_price', $params))) {
            $response = $this->privatePostStopOrderCreate (array_merge($request, $params));
        } else {
            $response = $this->privatePostOrderCreate (array_merge($request, $params));
        }
        $order = $this->parse_order($response['result']);
        $id = $this->safe_string($order, 'order_id');
        $this->orders[$id] = $order;
        return array_merge(array( 'info' => $response ), $order);
    }

    public function cancel_order ($id, $symbol = null, $params = array ()) {
        $this->load_markets();
        $request = array(
            'order_id' => $id,
        );
        $response = null;
        if (is_array($params) && array_key_exists('stop_px', $params)) {
            $response = $this->privatePostStopOrderCancel (array_merge($request, $params));
        } else {
            $response = $this->privatePostOrderCancel (array_merge($request, $params));
        }
        return $this->parse_order($response['result']);
    }

    public function fetch_deposits ($code = null, $since = null, $limit = null, $params = array ()) {
        $request = array(
            'wallet_fund_type' => 'Deposit',
        );
        if ($params !== null) {
            $request = array_replace_recursive($params, $request);
        }
        return $this->fetch_fund_records ($code, $since, $limit, $request);
    }

    public function fetch_withdrawals ($code = null, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $request = array();
        $currency = null;
        if ($code !== null) {
            $currency = $this->currency ($code);
            $request['coin'] = $currency;
        }
        if ($since !== null) {
            $request['start_date'] = $this->ymd ($since);
        }
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $reqParams = array_merge($request, $params);
        $response = $this->privateGetWalletWithdrawList ($reqParams);
        return $this->parse_transactions($this->safe_value($response['result'], 'data', array()), $currency, $since, $limit);
    }

    public function fetch_fund_records ($code = null, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $request = array();
        if ($since !== null) {
            $request['start_date'] = $this->ymd ($since);
        }
        if ($limit !== null) {
            $request['limit'] = $limit;
        }
        $currency = null;
        if ($code !== null) {
            $currency = $this->currency ($code);
            $request['coin'] = $currency;
        }
        $reqParams = array_merge($request, $params);
        $response = $this->privateGetWalletFundRecords ($reqParams);
        $transactions = $this->filter_by_array($this->safe_value($response['result'], 'data', array()), 'type', ['Withdraw', 'Deposit'], false);
        return $this->parse_transactions($transactions, $currency, $since, $limit);
    }

    public function parse_trade ($trade, $market = null) {
        $timestamp = $this->safe_timestamp($trade, 'exec_time');
        $price = $this->safe_float($trade, 'exec_price'); // USD
        $amount = $this->safe_float($trade, 'exec_value'); // BTC/ETH/XRP/EOS
        $id = $this->safe_string($trade, 'cross_seq');
        $order = $this->safe_string($trade, 'order_id');
        $side = $this->safe_string_lower($trade, 'side');
        $cost = $this->safe_float($trade, 'exec_qty');
        $execFee = $this->safe_float($trade, 'exec_fee');
        $feeRate = $this->safe_float($trade, 'fee_rate');
        $symbol = null;
        $marketId = $this->safe_string($trade, 'symbol');
        if ($marketId !== null) {
            if (is_array($this->markets_by_id) && array_key_exists($marketId, $this->markets_by_id)) {
                $market = $this->markets_by_id[$marketId];
                $symbol = $market['symbol'];
            } else {
                $symbol = $marketId;
            }
        }
        $fee = array(
            'cost' => $execFee,
            'currency' => $this->convert_symbol_to_currency ($symbol),
            'rate' => $feeRate,
        );
        $takerOrMaker = $fee['cost'] < 0 ? 'maker' : 'taker';
        $type = $this->safe_string_lower($trade, 'order_type');
        return array(
            'info' => $trade,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601 ($timestamp),
            'symbol' => $symbol,
            'id' => $id,
            'order' => $order,
            'type' => $type,
            'takerOrMaker' => $takerOrMaker,
            'side' => $side,
            'price' => $price,
            'cost' => $cost,
            'amount' => $amount,
            'fee' => $fee,
        );
    }

    public function parse_transaction ($transaction, $currency = null) {
        $id = $this->safe_string($transaction, 'id');
        // For deposits, $transactTime == $timestamp
        // For withdrawals, $transactTime is submission, $timestamp is processed
        $timestamp = $this->parse8601 ($this->safe_string($transaction, 'updated_at'));
        $transactTime = $this->parse8601 ($this->safe_string($transaction, 'submited_at'));
        $exec_time = $this->safe_string($transaction, 'exec_time'); // used for fetchFundRecords
        if ($exec_time !== null) {
            $transactTime = $this->parse8601 ($exec_time);
        }
        $type = $this->safe_string_lower($transaction, 'type');
        if ($type === null) {
            $type = 'withdrawal'; // privateGetWithdrawList has no `$type`
        }
        $type = $this->parse_transaction_type ($type);
        // Deposits have no from $address or to $address, withdrawals have both
        $address = null;
        $addressFrom = null;
        $addressTo = null;
        if ($type === 'withdrawal') {
            $addressFrom = $this->safe_string($transaction, 'address');
            $address = $addressFrom;
        } else if ($type === 'deposit') {
            $addressTo = $this->safe_string($transaction, 'address');
            $address = $addressTo;
        }
        $amount = $this->safe_float($transaction, 'amount');
        $feeCost = $this->safe_float($transaction, 'fee');
        $currency = $this->safe_string($transaction, 'coin');
        $fee = array(
            'cost' => $feeCost,
            'currency' => $currency,
        );
        $status = $this->safe_string($transaction, 'status');
        if ($status !== null) {
            $status = $this->parse_transaction_status ($status);
        }
        $txid = $this->safe_string_2($transaction, 'txid', 'tx_id');
        $tagTo = $this->safe_string($transaction, 'destination_tag');
        return array(
            'info' => $transaction,
            'id' => $id,
            'txid' => $txid,
            'timestamp' => $transactTime,
            'datetime' => $this->iso8601 ($transactTime),
            'addressFrom' => $addressFrom,
            'address' => $address,
            'addressTo' => $addressTo,
            'tagFrom' => null,
            'tag' => $tagTo,
            'tagTo' => $tagTo,
            'type' => $type,
            'amount' => $amount,
            'currency' => $currency,
            'status' => $status,
            'updated' => $timestamp,
            'comment' => null,
            'fee' => $fee,
        );
    }

    public function convert_symbol_to_currency ($symbol) {
        $symbolToCurrency = array(
            'BTCUSD' => 'BTC',
            'ETHUSD' => 'ETH',
            'XRPUSD' => 'XRP',
            'EOSUSD' => 'EOS',
        );
        return $this->safe_string($symbolToCurrency, $symbol, $symbol);
    }

    public function parse_transaction_status ($status) {
        $statuses = array(
            'Cancelled' => 'canceled',
            'Confirmation Email Expired' => 'canceled',
            'Transferred successfully' => 'ok',
            'Pending Email Confirmation' => 'pending',
            'Pending Review' => 'pending',
            'Pending Transfer' => 'pending',
            'Processing' => 'pending',
            'Rejected' => 'rejected',
            'Fail' => 'failed',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function parse_transaction_type ($transType) {
        $transTypes = array(
            'Deposit' => 'deposit',
            'Withdraw' => 'withdrawal',
            'withdraw' => 'withdrawal',
        );
        return $this->safe_string($transTypes, $transType, $transType);
    }

    public function parse_order ($order) {
        $status = $this->parse_order_status($this->safe_string_2($order, 'order_status', 'stop_order_status'));
        $symbol = $this->findSymbol ($this->safe_string($order, 'symbol'));
        $timestamp = $this->parse8601 ($this->safe_string($order, 'created_at'));
        $lastTradeTimestamp = $this->truncate ($this->safe_float($order, 'last_exec_time') * 1000, 0);
        $qty = $this->safe_float($order, 'qty'); // ordered $amount in quote currency
        $leaveQty = $this->safe_float($order, 'leaves_qty'); // leave $amount in quote currency
        $price = $this->safe_float($order, 'price'); // float $price in quote currency
        $amount = null; // ordered $amount of base currency
        $filled = $this->safe_float($order, 'cum_exec_value'); // $filled $amount of base currency, not return while place $order
        $remaining = $this->safe_float($order, 'leaves_value'); // leaves_value
        $cost = $qty - $leaveQty; // $filled * $price
        $average = null;
        if ($cost !== null) {
            if ($filled) {
                $average = $cost / $filled;
            }
        }
        $id = $this->safe_string_2($order, 'order_id', 'stop_order_id');
        $type = $this->safe_string_lower($order, 'order_type');
        $side = $this->safe_string_lower($order, 'side');
        $trades = null;
        $fee = null; // fy_todo array("currency":"xx", "$cost":xx, "rate":xx) `cum_exec_fee` not return now
        return array(
            'info' => $order,
            'id' => $id,
            'datetime' => $this->iso8601 ($timestamp),
            'timestamp' => $timestamp,
            'lastTradeTimestamp' => $lastTradeTimestamp,
            'status' => $status,
            'symbol' => $symbol,
            'type' => $type,
            'side' => $side,
            'price' => $price,
            'amount' => $amount,
            'filled' => $filled,
            'remaining' => $remaining,
            'cost' => $cost,
            'average' => $average,
            'trades' => $trades,
            'fee' => $fee,
        );
    }

    public function parse_order_status ($status) {
        $statuses = $this->order_statuses ();
        return $this->safe_string($statuses, $status, $status);
    }

    public function order_statuses ($filter = null) {
        $statuses = array(
            'Created' => 'created',
            'New' => 'open',
            'PartiallyFilled' => 'open',
            'Filled' => 'closed',
            'Cancelled' => 'canceled',
            'Rejected' => 'rejected',
            'Untriggered' => 'open',
            'Triggered' => 'open',
            'Active' => 'open',
        );
        if ($filter === null) {
            return $statuses;
        } else {
            $ret = array();
            $statusKeys = is_array($statuses) ? array_keys($statuses) : array();
            for ($i = 0; $i < count($statusKeys); $i++) {
                if ($statuses[$statusKeys[$i]] === $filter) {
                    $ret[$statusKeys[$i]] = $statuses[$statusKeys[$i]];
                }
            }
            return $ret;
        }
    }

    public function parse_tickers ($rawTickers, $symbols = null) {
        $tickers = array();
        for ($i = 0; $i < count($rawTickers); $i++) {
            $tickers[] = $this->parse_ticker($rawTickers[$i]);
        }
        return $this->filter_by_array($tickers, 'symbol', $symbols);
    }

    public function parse_ticker ($ticker, $market = null) {
        $timestamp = $this->safe_integer($ticker, 'close_time');
        $symbol = $this->findSymbol ($this->safe_string($ticker, 'symbol'), $market);
        $last = $this->safe_float($ticker, 'last_price');
        return array(
            'symbol' => $symbol,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601 ($timestamp),
            'high' => $this->safe_float($ticker, 'high_price_24h'),
            'low' => $this->safe_float($ticker, 'low_price_24h'),
            'bid' => $this->safe_float($ticker, 'bid_price'),
            'bidVolume' => null,
            'ask' => $this->safe_float($ticker, 'ask_price'),
            'askVolume' => null,
            'vwap' => null,
            'open' => null,
            'close' => $last,
            'last' => $last,
            'previousClose' => $this->safe_float($ticker, 'prev_price_24h'), // previous day close
            'change' => null,
            'percentage' => $this->safe_float($ticker, 'price_24h_pcnt'),
            'average' => null,
            'baseVolume' => $this->safe_float($ticker, 'turnover_24h'),
            'quoteVolume' => $this->safe_float($ticker, 'volume_24h'),
            'info' => $ticker,
        );
    }

    public function parse_ohlcv ($ohlcv, $market = null, $timeframe = '1m', $since = null, $limit = null) {
        return [
            $ohlcv['open_time'],
            floatval ($ohlcv['open']),
            floatval ($ohlcv['high']),
            floatval ($ohlcv['low']),
            floatval ($ohlcv['close']),
            floatval ($ohlcv['volume']),
        ];
    }

    public function request ($path, $api = 'public', $method = 'GET', $params = array (), $headers = null, $body = null) {
        $response = $this->fetch2 ($path, $api, $method, $params, $headers, $body);
        if (is_array($response) && array_key_exists('ret_code', $response)) {
            if ($response['ret_code'] === 0) {
                return $response;
            }
        }
        throw new ExchangeError($this->id . ' ' . $this->json ($response));
    }

    public function sign ($path, $api = 'public', $method = 'GET', $params = array (), $headers = null, $body = null) {
        $url = '';
        $env = 'api';
        if ($this->debug) {
            $env = 'test';
        }
        $url = $this->urls[$env][$api] . '/' . $path;
        $headers = array(
            'Content-Type' => 'application/x-www-form-urlencoded',
        );
        if (($api === 'private') || ($api === 'wapi') || (mb_strpos($path, 'private') !== false)) {
            $query = array_merge(array(
                'api_key' => $this->apiKey,
                'timestamp' => $this->nonce (),
                'recv_window' => $this->options['recvWindow'],
            ), $params);
            $sortedQuery = array();
            $queryKeys = is_array($query) ? array_keys($query) : array();
            $queryKeys->sort ();
            for ($i = 0; $i < count($queryKeys); $i++) {
                $sortedQuery[$queryKeys[$i]] = $query[$queryKeys[$i]];
            }
            $queryStr = $this->rawencode ($sortedQuery);
            $signature = $this->hmac ($queryStr, $this->encode ($this->secret));
            $queryStr .= '&' . 'sign=' . $signature;
            $url .= '?' . $queryStr;
        } else {
            if ($params) {
                $queryStr = '';
                $queryStr .= '&' . $this->urlencode ($params);
                $url .= '?' . $queryStr;
            }
        }
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }

    public function handle_errors ($statusCode, $statusText, $url, $method, $responseHeaders, $responseBody, $response, $requestHeaders, $requestBody) {
        if ($statusCode >= 500) {
            throw new ExchangeNotAvailable($this->id . ' ' . $statusText);
        }
        $ret_code = $this->safe_value($response, 'ret_code', -1);
        $exceptions = $this->exceptions;
        if (is_array($exceptions) && array_key_exists($ret_code, $exceptions)) {
            $ExceptionClass = $exceptions[$ret_code];
            throw new $ExceptionClass($this->id . ' ' . $this->json ($response));
        }
    }
}
