<?php

namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import

class coinflex extends Exchange {

    public function describe () {
        return array_replace_recursive(parent::describe (), array(
            'id' => 'coinflex',
            'name' => 'CoinFlex',
            'countries' => array( 'SC' ), // Seychelles
            'rateLimit' => 2000,
            'urls' => array(
                'www' => 'https://coinflex.com/',
                'api' => array(
                    'public' => 'https://webapi.coinflex.com',
                    'private' => 'https://webapi.coinflex.com',
                ),
                'fees' => 'https://coinflex.com/fees/',
                'doc' => array(
                    'https://github.com/coinflex-exchange/API/blob/master/REST.md',
                ),
            ),
            'api' => array(
                'public' => array(
                    'get' => array(
                        'assets/',
                        'markets/',
                        'tickers/',
                        'tickers/{base}:{counter}',
                        'depth/{base}:{counter}',
                    ),
                ),
                'private' => array(
                    'get' => array(
                        'balances/',
                        'orders/',
                        'orders/{id}',
                        'trades/',
                        'trades/{time}',
                    ),
                    'post' => array(
                        'orders/',
                    ),
                    'delete' => array(
                        'orders/',
                        'orders/{id}',
                    ),
                ),
            ),
            'has' => array(
                'fetchCurrencies' => true,
                'fetchMarkets' => true,
                'fetchTickers' => true,
                'fetchTicker' => true,
                'fetchOrderBook' => true,
                'fetchBalance' => true,
                'fetchOpenOrders' => true,
                'fetchOrder' => true,
                'cancelAllOrders' => true,
                'cancelOrder' => true,
                'fetchMyTrades' => true,
                'fetchTrades' => false,
                'fetchOHLCV' => false,
            ),
            'requiredCredentials' => array(
                'apiKey' => true,
                'privateKey' => true,
                'uid' => true,
                'secret' => false,
            ),
            'options' => array(
                'fetchCurrencies' => array(
                    'expires' => 5000,
                ),
            ),
        ));
    }

    public function fetch_currencies ($params = array ()) {
        $answer = $this->fetch_currencies_from_cache ($params);
        $assets = $this->safe_value($answer, 'currencies');
        $result = array();
        for ($i = 0; $i < count($assets); $i++) {
            $asset = $assets[$i];
            $code = $this->safe_currency_code($this->safe_string_2($asset, 'name', 'spot_name'));
            $result[$code] = array(
                'id' => $this->safe_integer($asset, 'id'),
                'code' => $code,
                'name' => $code,
                'active' => true,
                'fee' => null,
                'precision' => null,
                'limits' => array(
                    'amount' => array(
                        'min' => null,
                        'max' => null,
                    ),
                    'price' => array(
                        'min' => null,
                        'max' => null,
                    ),
                    'cost' => array(
                        'min' => null,
                        'max' => null,
                    ),
                    'withdraw' => array(
                        'min' => null,
                        'max' => null,
                    ),
                ),
                'info' => $asset,
            );
        }
        return $result;
    }

    public function fetch_currencies_from_cache ($params = array ()) {
        $options = $this->safe_value($this->options, 'fetchCurrencies', array());
        $timestamp = $this->safe_integer($options, 'timestamp');
        $expires = $this->safe_integer($options, 'expires', 5000);
        $now = $this->milliseconds ();
        if (($timestamp === null) || (($now - $timestamp) > $expires)) {
            $currencies = $this->publicGetAssets ($params);
            $this->options['fetchCurrencies'] = array_merge($options, array(
                'currencies' => $currencies,
                'timestamp' => $now,
            ));
        }
        return $this->safe_value($this->options, 'fetchCurrencies', array());
    }

    public function fetch_markets ($params = array ()) {
        $currencies = $this->fetch_currencies();
        $markets = $this->publicGetMarkets ();
        $result = array();
        for ($i = 0; $i < count($markets); $i++) {
            $market = $markets[$i];
            $baseId = $this->safe_integer($market, 'base');
            $base = $this->find_currency_by_id ($currencies, $baseId);
            $quoteId = $this->safe_integer($market, 'counter');
            $quote = $this->find_currency_by_id ($currencies, $quoteId);
            $symbol = $base . '/' . $quote;
            $active = true;
            $expires = $this->safe_integer($market, 'expires');
            if ($expires !== null) {
                if ($this->milliseconds () > $expires) {
                    $active = false;
                }
            }
            $result[] = array(
                'id' => $this->safe_string($market, 'name'),
                'symbol' => $symbol,
                'base' => $base,
                'quote' => $quote,
                'baseId' => $baseId,
                'quoteId' => $quoteId,
                'active' => $active,
                'precision' => null,
                'limits' => null,
                'info' => $market,
            );
        }
        return $result;
    }

    public function fetch_tickers ($symbols = null, $params = array ()) {
        $this->load_markets();
        $response = $this->publicGetTickers ($params);
        $result = array();
        for ($i = 0; $i < count($response); $i++) {
            $ticker = $this->parse_ticker($response[$i]);
            $symbol = $ticker['symbol'];
            $result[$symbol] = $ticker;
        }
        return $result;
    }

    public function fetch_ticker ($symbol = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market ($symbol);
        $request = array(
            'base' => $market['baseId'],
            'counter' => $market['quoteId'],
        );
        $response = $this->publicGetTickersBaseCounter (array_merge($request, $params));
        return $this->parse_ticker($response);
    }

    public function parse_ticker ($ticker, $market = null) {
        if ($market === null) {
            $baseId = $this->safe_integer($ticker, 'base');
            $base = $this->find_currency_by_id ($this->currencies, $baseId);
            $quoteId = $this->safe_integer($ticker, 'counter');
            $quote = $this->find_currency_by_id ($this->currencies, $quoteId);
            $symbol = $base . '/' . $quote;
            $market = $this->market ($symbol);
        }
        $timestamp = $this->safe_integer($ticker, 'time'); // in microseconds
        $timestamp = intval ($timestamp / 1000000);
        $last = $this->safe_float($ticker, 'last');
        return array(
            'symbol' => $market['symbol'],
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601 ($timestamp),
            'high' => $this->safe_float($ticker, 'high'),
            'low' => $this->safe_float($ticker, 'low'),
            'bid' => $this->safe_float($ticker, 'bid'),
            'bidVolume' => null,
            'ask' => $this->safe_float($ticker, 'ask'),
            'askVolume' => null,
            'vwap' => null,
            'open' => null,
            'close' => $last,
            'last' => $last,
            'previousClose' => null,
            'change' => null,
            'percentage' => null,
            'average' => null,
            'baseVolume' => $this->safe_float($ticker, 'volume'),
            'quoteVolume' => null,
            'info' => $ticker,
        );
    }

    public function create_order ($symbol, $type, $side, $amount, $price = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market ($symbol);
        if ($side === 'sell') {
            $amount *= -1;
        }
        $baseAsset = $this->currencies[$market['base']];
        $baseScale = $this->safe_integer($baseAsset['info'], 'scale');
        $quoteAsset = $this->currencies[$market['quote']];
        $quoteScale = $this->safe_integer($quoteAsset['info'], 'scale');
        $request = array(
            'base' => $market['baseId'],
            'counter' => $market['quoteId'],
        );
        if ($type === 'limit') {
            $request['price'] = $price * $quoteScale;
        }
        $request['quantity'] = $amount * $baseScale;
        $response = $this->privatePostOrders (array_merge($request, $params));
        if (is_array($response) && array_key_exists('remaining', $response)) {
            return array();
        } else {
            return $this->parse_order($response);
        }
    }

    public function fetch_order_book ($symbol, $limit = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market ($symbol);
        $request = array(
            'base' => $market['baseId'],
            'counter' => $market['quoteId'],
        );
        $response = $this->publicGetDepthBaseCounter (array_merge($request, $params));
        return $this->parse_order_book($response);
    }

    public function fetch_order ($id, $symbol = null, $params = array ()) {
        $this->load_markets();
        $request = array(
            'id' => intval ($id),
        );
        $response = $this->privateGetOrdersId (array_merge($request, $params));
        return $this->parse_order($response);
    }

    public function fetch_balance ($params = array ()) {
        $this->load_markets();
        $response = $this->privateGetBalances ($params);
        $result = array(
            'info' => $response,
        );
        for ($i = 0; $i < count($response); $i++) {
            $balance = $response[$i];
            $id = $this->safe_integer($balance, 'id');
            $currency = $this->find_currency_by_id ($this->currencies, $id);
            $available = $this->safe_float($balance, 'available');
            $reserved = $this->safe_float($balance, 'reserved');
            $asset = $this->safe_value($this->currencies, $currency);
            $scale = $this->safe_integer($asset['info'], 'scale');
            if ($scale > 0) {
                $available /= $scale;
                $reserved /= $scale;
            }
            $result[$currency] = array(
                'free' => $available,
                'used' => $reserved,
                'total' => $this->sum ($available, $reserved),
            );
        }
        return $this->parse_balance($result);
    }

    public function fetch_open_orders ($symbol = null, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $result = $this->privateGetOrders ($params);
        $orders = $this->parse_orders($result, null, $since, $limit);
        $orders = $this->filter_by($orders, 'symbol', $symbol);
        return $orders;
    }

    public function cancel_order ($id, $symbol = null, $params = array ()) {
        $this->load_markets();
        $request = array(
            'id' => intval ($id),
        );
        return $this->privateDeleteOrdersId (array_merge($request, $params));
    }

    public function cancel_all_orders ($symbol = null, $params = array ()) {
        return $this->privateDeleteOrders ($params);
    }

    public function parse_order ($order, $market = null) {
        $timestamp = $this->safe_integer($order, 'time');
        $timestamp = intval ($timestamp / 1000);
        $baseId = $this->safe_integer($order, 'base');
        $base = $this->find_currency_by_id ($this->currencies, $baseId);
        $baseAsset = $this->currencies[$base];
        $baseScale = $this->safe_integer($baseAsset['info'], 'scale');
        $quoteId = $this->safe_integer($order, 'counter');
        $quote = $this->find_currency_by_id ($this->currencies, $quoteId);
        $quoteAsset = $this->currencies[$quote];
        $quoteScale = $this->safe_integer($quoteAsset['info'], 'scale');
        $symbol = $base . '/' . $quote;
        $amount = $this->safe_float($order, 'quantity');
        $side = null;
        if ($amount > 0) {
            $side = 'buy';
        } else if ($amount < 0) {
            $side = 'sell';
            $amount *= -1;
        }
        if ($baseScale > 0) {
            $amount /= $baseScale;
        }
        $price = $this->safe_float($order, 'price');
        if ($quoteScale > 0) {
            $price /= $quoteScale;
        }
        return array(
            'id' => $this->safe_integer($order, 'id'),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601 ($timestamp),
            'lastTradeTimestamp' => null,
            'symbol' => $symbol,
            'type' => null,
            'side' => $side,
            'price' => $price,
            'average' => null,
            'amount' => $amount,
            'remaining' => null,
            'filled' => null,
            'status' => null,
            'fee' => null,
            'info' => $order,
        );
    }

    public function fetch_my_trades ($symbol = null, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $request = array();
        $response = null;
        if (is_array($params) && array_key_exists('id', $params)) {
            $request['time'] = $this->safe_integer($params, 'id');
            $query = $this->omit ($params, 'id');
            $response = $this->privateGetTradesTime (array_merge($request, $query));
            $responseArray = array();
            $responseArray[] = $response;
            $response = $responseArray;
        } else {
            $response = $this->privateGetTrades (array_merge($request, $params));
        }
        return $this->parse_trades($response, null, $since, $limit);
    }

    public function parse_trade ($trade, $market) {
        $id = $this->safe_string($trade, 'time');
        $timestamp = intval ($id / 1000);
        $baseId = $this->safe_integer($trade, 'base');
        $base = $this->find_currency_by_id ($this->currencies, $baseId);
        $baseAsset = $this->currencies[$base];
        $baseScale = $this->safe_integer($baseAsset['info'], 'scale');
        $quoteId = $this->safe_integer($trade, 'counter');
        $quote = $this->find_currency_by_id ($this->currencies, $quoteId);
        $quoteAsset = $this->currencies[$quote];
        $quoteScale = $this->safe_integer($quoteAsset['info'], 'scale');
        $symbol = $base . '/' . $quote;
        $market = $this->market ($symbol);
        $amount = $this->safe_integer($trade, 'quantity');
        $side = null;
        if ($amount !== null) {
            if ($amount > 0) {
                $side = 'buy';
            } else if ($amount < 0) {
                $side = 'sell';
                $amount *= -1;
            }
            if ($baseScale > 0) {
                $amount /= $baseScale;
            }
        }
        $price = $this->safe_float($trade, 'price');
        if ($price !== null) {
            if ($quoteScale > 0) {
                $price /= $quoteScale;
            }
        }
        $cost = null;
        if ($price !== null) {
            if ($amount !== null) {
                $cost = $price * $amount;
            }
        }
        $fee = null;
        if (is_array($trade) && array_key_exists('counter_fee', $trade)) {
            $cost = $this->safe_integer($trade, 'counter_fee');
            if ($cost !== null) {
                $cost /= $quoteScale;
                $fee = array(
                    'cost' => $cost,
                    'currency' => $quote,
                );
            }
        }
        return array(
            'id' => $id,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601 ($timestamp),
            'symbol' => $market['symbol'],
            'type' => null,
            'order' => $this->safe_string($trade, 'order_id'),
            'side' => $side,
            'takerOrMaker' => null,
            'price' => $price,
            'amount' => $amount,
            'cost' => $cost,
            'fee' => $fee,
            'info' => $trade,
        );
    }

    public function find_currency_by_id ($currencies, $id) {
        if ($id === null) {
            throw new ArgumentsRequired('Should specify id');
        }
        $keys = is_array($currencies) ? array_keys($currencies) : array();
        for ($i = 0; $i < count($keys); $i++) {
            $key = $keys[$i];
            $currency = $currencies[$key];
            $currencyId = $this->safe_integer($currency, 'id');
            if ($currencyId === $id) {
                return $currency['code'];
            }
        }
        throw new ExchangeError('Currency with $id ' . $id . ' not founded');
    }

    public function sign ($path, $api = 'public', $method = 'GET', $params = array (), $headers = null, $body = null) {
        $base = $this->urls['api'][$api];
        $request = '/' . $this->implode_params($path, $params);
        $url = $base . $request;
        $query = $this->omit ($params, $this->extract_params($path));
        $suffix = '';
        if ($query) {
            $suffix = $this->urlencode ($query);
        }
        if ($method === 'GET') {
            if (strlen($suffix)) {
                $url = $url . '?' . $suffix;
            }
        }
        if ($api === 'private') {
            $this->check_required_credentials();
            $sid = (string) $this->uid . '/' . $this->apiKey . ':' . $this->privateKey;
            $encodedSid = $this->encode ($sid);
            $base64Sid = base64_encode($encodedSid);
            $headers = array(
                'Authorization' => 'Basic ' . $this->decode ($base64Sid),
            );
            if ($method === 'POST') {
                $body = $suffix;
                $headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }

    public function handle_errors ($code, $reason, $url, $method, $headers, $body, $response, $requestHeaders, $requestBody) {
        if ($code === 400) {
            if ($method === 'POST') {
                if (mb_strpos($url, 'orders/') > -1) {
                    throw new InvalidOrder($body);
                }
            }
        }
        if ($code === 403) {
            if ($method === 'POST') {
                if (mb_strpos($url, 'orders/') > -1) {
                    if (mb_strpos($body, 'insufficient funds') > -1) {
                        throw new InsufficientFunds($body);
                    }
                }
            }
        }
        if ($code === 404) {
            if ($method === 'GET' || $method === 'DELETE') {
                if (mb_strpos($url, 'orders/') > -1) {
                    $index = mb_strpos($url, 'orders/');
                    $id = mb_substr($url, $index . 7);
                    throw new OrderNotFound($id);
                }
                if (mb_strpos($url, 'trades/') > -1) {
                    $index = mb_strpos($url, 'trades/');
                    $id = mb_substr($url, $index . 7);
                    throw new BadRequest('Trade with $id ' . $id . ' not found');
                }
            }
        }
    }
}
