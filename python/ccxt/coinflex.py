# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.base.exchange import Exchange
import base64
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import ArgumentsRequired
from ccxt.base.errors import BadRequest
from ccxt.base.errors import InsufficientFunds
from ccxt.base.errors import InvalidOrder
from ccxt.base.errors import OrderNotFound


class coinflex(Exchange):

    def describe(self):
        return self.deep_extend(super(coinflex, self).describe(), {
            'id': 'coinflex',
            'name': 'CoinFlex',
            'countries': ['SC'],  # Seychelles
            'rateLimit': 2000,
            'urls': {
                'www': 'https://coinflex.com/',
                'api': {
                    'public': 'https://webapi.coinflex.com',
                    'private': 'https://webapi.coinflex.com',
                },
                'fees': 'https://coinflex.com/fees/',
                'doc': [
                    'https://github.com/coinflex-exchange/API/blob/master/REST.md',
                ],
            },
            'api': {
                'public': {
                    'get': [
                        'assets/',
                        'markets/',
                        'tickers/',
                        'tickers/{base}:{counter}',
                        'depth/{base}:{counter}',
                    ],
                },
                'private': {
                    'get': [
                        'balances/',
                        'orders/',
                        'orders/{id}',
                        'trades/',
                        'trades/{time}',
                    ],
                    'post': [
                        'orders/',
                    ],
                    'delete': [
                        'orders/',
                        'orders/{id}',
                    ],
                },
            },
            'has': {
                'fetchCurrencies': True,
                'fetchMarkets': True,
                'fetchTickers': True,
                'fetchTicker': True,
                'fetchOrderBook': True,
                'fetchBalance': True,
                'fetchOpenOrders': True,
                'fetchOrder': True,
                'cancelAllOrders': True,
                'cancelOrder': True,
                'fetchMyTrades': True,
                'fetchTrades': False,
                'fetchOHLCV': False,
            },
            'requiredCredentials': {
                'apiKey': True,
                'privateKey': True,
                'uid': True,
                'secret': False,
            },
            'options': {
                'fetchCurrencies': {
                    'expires': 5000,
                },
            },
        })

    def fetch_currencies(self, params={}):
        answer = self.fetch_currencies_from_cache(params)
        assets = self.safe_value(answer, 'currencies')
        result = {}
        for i in range(0, len(assets)):
            asset = assets[i]
            code = self.safe_currency_code(self.safe_string_2(asset, 'name', 'spot_name'))
            result[code] = {
                'id': self.safe_integer(asset, 'id'),
                'code': code,
                'name': code,
                'active': True,
                'fee': None,
                'precision': None,
                'limits': {
                    'amount': {
                        'min': None,
                        'max': None,
                    },
                    'price': {
                        'min': None,
                        'max': None,
                    },
                    'cost': {
                        'min': None,
                        'max': None,
                    },
                    'withdraw': {
                        'min': None,
                        'max': None,
                    },
                },
                'info': asset,
            }
        return result

    def fetch_currencies_from_cache(self, params={}):
        options = self.safe_value(self.options, 'fetchCurrencies', {})
        timestamp = self.safe_integer(options, 'timestamp')
        expires = self.safe_integer(options, 'expires', 5000)
        now = self.milliseconds()
        if (timestamp is None) or ((now - timestamp) > expires):
            currencies = self.publicGetAssets(params)
            self.options['fetchCurrencies'] = self.extend(options, {
                'currencies': currencies,
                'timestamp': now,
            })
        return self.safe_value(self.options, 'fetchCurrencies', {})

    def fetch_markets(self, params={}):
        currencies = self.fetch_currencies()
        markets = self.publicGetMarkets()
        result = []
        for i in range(0, len(markets)):
            market = markets[i]
            baseId = self.safe_integer(market, 'base')
            base = self.find_currency_by_id(currencies, baseId)
            quoteId = self.safe_integer(market, 'counter')
            quote = self.find_currency_by_id(currencies, quoteId)
            symbol = base + '/' + quote
            active = True
            expires = self.safe_integer(market, 'expires')
            if expires is not None:
                if self.milliseconds() > expires:
                    active = False
            result.append({
                'id': self.safe_string(market, 'name'),
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'baseId': baseId,
                'quoteId': quoteId,
                'active': active,
                'precision': None,
                'limits': None,
                'info': market,
            })
        return result

    def fetch_tickers(self, symbols=None, params={}):
        self.load_markets()
        response = self.publicGetTickers(params)
        result = {}
        for i in range(0, len(response)):
            ticker = self.parse_ticker(response[i])
            symbol = ticker['symbol']
            result[symbol] = ticker
        return result

    def fetch_ticker(self, symbol=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'base': market['baseId'],
            'counter': market['quoteId'],
        }
        response = self.publicGetTickersBaseCounter(self.extend(request, params))
        return self.parse_ticker(response)

    def parse_ticker(self, ticker, market=None):
        if market is None:
            baseId = self.safe_integer(ticker, 'base')
            base = self.find_currency_by_id(self.currencies, baseId)
            quoteId = self.safe_integer(ticker, 'counter')
            quote = self.find_currency_by_id(self.currencies, quoteId)
            symbol = base + '/' + quote
            market = self.market(symbol)
        timestamp = self.safe_integer(ticker, 'time')  # in microseconds
        timestamp = int(timestamp / 1000000)
        last = self.safe_float(ticker, 'last')
        return {
            'symbol': market['symbol'],
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'high': self.safe_float(ticker, 'high'),
            'low': self.safe_float(ticker, 'low'),
            'bid': self.safe_float(ticker, 'bid'),
            'bidVolume': None,
            'ask': self.safe_float(ticker, 'ask'),
            'askVolume': None,
            'vwap': None,
            'open': None,
            'close': last,
            'last': last,
            'previousClose': None,
            'change': None,
            'percentage': None,
            'average': None,
            'baseVolume': self.safe_float(ticker, 'volume'),
            'quoteVolume': None,
            'info': ticker,
        }

    def create_order(self, symbol, type, side, amount, price=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        if side == 'sell':
            amount *= -1
        baseAsset = self.currencies[market['base']]
        baseScale = self.safe_integer(baseAsset['info'], 'scale')
        quoteAsset = self.currencies[market['quote']]
        quoteScale = self.safe_integer(quoteAsset['info'], 'scale')
        request = {
            'base': market['baseId'],
            'counter': market['quoteId'],
        }
        if type == 'limit':
            request['price'] = price * quoteScale
        request['quantity'] = amount * baseScale
        response = self.privatePostOrders(self.extend(request, params))
        if 'remaining' in response:
            return []
        else:
            return self.parse_order(response)

    def fetch_order_book(self, symbol, limit=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'base': market['baseId'],
            'counter': market['quoteId'],
        }
        response = self.publicGetDepthBaseCounter(self.extend(request, params))
        return self.parse_order_book(response)

    def fetch_order(self, id, symbol=None, params={}):
        self.load_markets()
        request = {
            'id': int(id),
        }
        response = self.privateGetOrdersId(self.extend(request, params))
        return self.parse_order(response)

    def fetch_balance(self, params={}):
        self.load_markets()
        response = self.privateGetBalances(params)
        result = {
            'info': response,
        }
        for i in range(0, len(response)):
            balance = response[i]
            id = self.safe_integer(balance, 'id')
            currency = self.find_currency_by_id(self.currencies, id)
            available = self.safe_float(balance, 'available')
            reserved = self.safe_float(balance, 'reserved')
            asset = self.safe_value(self.currencies, currency)
            scale = self.safe_integer(asset['info'], 'scale')
            if scale > 0:
                available /= scale
                reserved /= scale
            result[currency] = {
                'free': available,
                'used': reserved,
                'total': self.sum(available, reserved),
            }
        return self.parse_balance(result)

    def fetch_open_orders(self, symbol=None, since=None, limit=None, params={}):
        self.load_markets()
        result = self.privateGetOrders(params)
        orders = self.parse_orders(result, None, since, limit)
        orders = self.filter_by(orders, 'symbol', symbol)
        return orders

    def cancel_order(self, id, symbol=None, params={}):
        self.load_markets()
        request = {
            'id': int(id),
        }
        return self.privateDeleteOrdersId(self.extend(request, params))

    def cancel_all_orders(self, symbol=None, params={}):
        return self.privateDeleteOrders(params)

    def parse_order(self, order, market=None):
        timestamp = self.safe_integer(order, 'time')
        timestamp = int(timestamp / 1000)
        baseId = self.safe_integer(order, 'base')
        base = self.find_currency_by_id(self.currencies, baseId)
        baseAsset = self.currencies[base]
        baseScale = self.safe_integer(baseAsset['info'], 'scale')
        quoteId = self.safe_integer(order, 'counter')
        quote = self.find_currency_by_id(self.currencies, quoteId)
        quoteAsset = self.currencies[quote]
        quoteScale = self.safe_integer(quoteAsset['info'], 'scale')
        symbol = base + '/' + quote
        amount = self.safe_float(order, 'quantity')
        side = None
        if amount > 0:
            side = 'buy'
        elif amount < 0:
            side = 'sell'
            amount *= -1
        if baseScale > 0:
            amount /= baseScale
        price = self.safe_float(order, 'price')
        if quoteScale > 0:
            price /= quoteScale
        return {
            'id': self.safe_integer(order, 'id'),
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'lastTradeTimestamp': None,
            'symbol': symbol,
            'type': None,
            'side': side,
            'price': price,
            'average': None,
            'amount': amount,
            'remaining': None,
            'filled': None,
            'status': None,
            'fee': None,
            'info': order,
        }

    def fetch_my_trades(self, symbol=None, since=None, limit=None, params={}):
        self.load_markets()
        request = {}
        response = None
        if 'id' in params:
            request['time'] = self.safe_integer(params, 'id')
            query = self.omit(params, 'id')
            response = self.privateGetTradesTime(self.extend(request, query))
            responseArray = []
            responseArray.append(response)
            response = responseArray
        else:
            response = self.privateGetTrades(self.extend(request, params))
        return self.parse_trades(response, None, since, limit)

    def parse_trade(self, trade, market):
        id = self.safe_string(trade, 'time')
        timestamp = int(id / 1000)
        baseId = self.safe_integer(trade, 'base')
        base = self.find_currency_by_id(self.currencies, baseId)
        baseAsset = self.currencies[base]
        baseScale = self.safe_integer(baseAsset['info'], 'scale')
        quoteId = self.safe_integer(trade, 'counter')
        quote = self.find_currency_by_id(self.currencies, quoteId)
        quoteAsset = self.currencies[quote]
        quoteScale = self.safe_integer(quoteAsset['info'], 'scale')
        symbol = base + '/' + quote
        market = self.market(symbol)
        amount = self.safe_integer(trade, 'quantity')
        side = None
        if amount is not None:
            if amount > 0:
                side = 'buy'
            elif amount < 0:
                side = 'sell'
                amount *= -1
            if baseScale > 0:
                amount /= baseScale
        price = self.safe_float(trade, 'price')
        if price is not None:
            if quoteScale > 0:
                price /= quoteScale
        cost = None
        if price is not None:
            if amount is not None:
                cost = price * amount
        fee = None
        if 'counter_fee' in trade:
            cost = self.safe_integer(trade, 'counter_fee')
            if cost is not None:
                cost /= quoteScale
                fee = {
                    'cost': cost,
                    'currency': quote,
                }
        return {
            'id': id,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'symbol': market['symbol'],
            'type': None,
            'order': self.safe_string(trade, 'order_id'),
            'side': side,
            'takerOrMaker': None,
            'price': price,
            'amount': amount,
            'cost': cost,
            'fee': fee,
            'info': trade,
        }

    def find_currency_by_id(self, currencies, id):
        if id is None:
            raise ArgumentsRequired('Should specify id')
        keys = list(currencies.keys())
        for i in range(0, len(keys)):
            key = keys[i]
            currency = currencies[key]
            currencyId = self.safe_integer(currency, 'id')
            if currencyId == id:
                return currency['code']
        raise ExchangeError('Currency with id ' + id + ' not founded')

    def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        base = self.urls['api'][api]
        request = '/' + self.implode_params(path, params)
        url = base + request
        query = self.omit(params, self.extract_params(path))
        suffix = ''
        if query:
            suffix = self.urlencode(query)
        if method == 'GET':
            if len(suffix):
                url = url + '?' + suffix
        if api == 'private':
            self.check_required_credentials()
            sid = str(self.uid) + '/' + self.apiKey + ':' + self.privateKey
            encodedSid = self.encode(sid)
            base64Sid = base64.b64encode(encodedSid)
            headers = {
                'Authorization': 'Basic ' + self.decode(base64Sid),
            }
            if method == 'POST':
                body = suffix
                headers['Content-Type'] = 'application/x-www-form-urlencoded'
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    def handle_errors(self, code, reason, url, method, headers, body, response, requestHeaders, requestBody):
        if code == 400:
            if method == 'POST':
                if url.find('orders/') > -1:
                    raise InvalidOrder(body)
        if code == 403:
            if method == 'POST':
                if url.find('orders/') > -1:
                    if body.find('insufficient funds') > -1:
                        raise InsufficientFunds(body)
        if code == 404:
            if method == 'GET' or method == 'DELETE':
                if url.find('orders/') > -1:
                    index = url.find('orders/')
                    id = url[index + 7:]
                    raise OrderNotFound(id)
                if url.find('trades/') > -1:
                    index = url.find('trades/')
                    id = url[index + 7:]
                    raise BadRequest('Trade with id ' + id + ' not found')
